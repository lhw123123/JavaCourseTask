年轻代收集器（全部采用复制算法实现）

Serial 串行垃圾回收器与Serial Old搭配使用 启动时用-XX:+UseSerialGC指定 “Stop The World”
Serial收集器是最基础、历史最悠久的收集器，曾经(在JDK 1.3.1之前)是HotSpot虚拟机新生代收集器的唯一选择。它收集时必须暂停其他所有工作线程，直到它收集结束。
该垃圾收集器只适合几百MB堆内存的JVM，而且单核CPU时比较有用。

ParNew 并行垃圾回收器与CMS搭配使用 启动时用-XX:+UseConcMarkSweepGC指定 Stop The World
ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数、收集算法、
对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。除了同时使用多条线程进行垃圾收集ParNew收集器除了
支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处。

Parallel Scavenge 并行垃圾回收器与Parallel Old搭配使用 启动时用-XX:+UseParallelGC指定 “Stop The World”
Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)。自适应调节策略是区别于ParNew收集器的一个重要特性。经常被称作“吞吐量优先收集器”。
该垃圾收集器适用于多核服务器，主要目标是增加吞吐量。因为对系统资源的有效使用，能达到更高的吞吐量:
   在GC期间，所有 CPU 内核都在并行清理垃圾，所以总暂停时间更短；
   在两次GC周期的间隔期，没有GC线程在运行，不会消耗任何系统资源。


老年代收集器

Serial Old收集器（使用标记-整理算法）
Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途:
一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用。
另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。

Parallel Old收集器（使用标记-整理算法）
Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并行收集。这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器
一直处于相当尴尬的状态，原因是如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old(PS MarkSweep)收集器别无选择，其它表现良好的老年代收集器，如
CMS无法与它配合工作。

CMS收集器（标记-清除算法实现）
CMS收集器是一种以获取最短回收停顿时间为目标的收集器。它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括:      
1)初始标记(CMS initial mark)       
2)并发标记(CMS concurrent mark) 
  并发预清理    
  可取消的并发预清理  
3)重新标记(CMS remark)       
4)并发清除(CMS concurrent sweep)
  并发重置      
CMS是一款优秀的收集器，它最主要的优点在名字上已经体现出来:并发收集、低停顿，一些官方公开文档里面也称之为“并发低停顿收集器”(Concurrent Low Pause Collector)。
CMS GC的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：
   第一，不对老年代进行整理，而是使用空闲列表(free-lists)来管理内存空间的回收。
   第二，在 mark-and-sweep (标记-清除) 阶段的大部分工作和应用线程一起并发执行。
也就是说，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢CPU时间。默认情况下，CMS 使用的并发线程数等于CPU核心数的 1/4 。

 

整堆收集器

G1收集器 启动时用-XX:+UseG1GC -XX:MaxGCPauseMillis=50 指定
Garbage First(简称G1)收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。
G1是一款主要面向服务端应用的垃圾收集器。JDK9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，
而CMS则沦落至被声明为不推荐使用(Deprecate)的收集器。如果对JDK 9及以上版本的HotSpot虚拟机使用 参数-XX:+UseConcMarkSweep GC来开启CMS
收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。
G1 GC最主要的设计目标是：将STW停顿的时间和分布，变成可预期且可配置的。适合大内存，需要较低延迟的场景。
事实上，G1 GC是一款软实时垃圾收集器，可以为其设置某项特定的性能指标。例如可以指定: 在任意x毫秒时间范围内，STW停顿不得超过y毫秒。 
举例说明: 任意 1秒 内暂停时间不超过 5毫秒 。G1 GC会尽力达成这个目标（有很大概率会满足，但并不完全确定）。
构建回收集的原则是： 垃圾最多的小块会被优先收集。这也是G1名称的由来。




